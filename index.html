<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hand Controlled 3D Particles</title>
<link rel="icon" href="icon.png" type="image/x-icon">

<style>
  body { margin: 0; overflow: hidden; background: black; }
  video {
    position: fixed;
    right: 10px;
    bottom: 10px;
    width: 180px;
    opacity: 0.7;
    z-index: 10;
  }
</style>
</head>

<body>
<video id="video" autoplay muted playsinline></video>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ================= THREE SETUP ================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  75, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.z = 90;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= PARTICLES ================= */
const COUNT = 4500;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const targetPositions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);
const color = new THREE.Color();

for (let i = 0; i < COUNT; i++) {
  positions[i*3] = (Math.random()-0.5)*60;
  positions[i*3+1] = (Math.random()-0.5)*60;
  positions[i*3+2] = (Math.random()-0.5)*60;

  targetPositions[i*3] = positions[i*3];
  targetPositions[i*3+1] = positions[i*3+1];
  targetPositions[i*3+2] = positions[i*3+2];

  color.setHSL(Math.random(), 1, 0.6);
  colors[i*3] = color.r;
  colors[i*3+1] = color.g;
  colors[i*3+2] = color.b;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
  size: 1.5,
  vertexColors: true,
  transparent: true
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* ================= TRANSITION MODES (15+) ================= */
const MODES = [
  "heart","flower","saturn","firework",
  "spiral","wave","galaxy","vortex",
  "dna","sphere","ring","helix",
  "cube","explosion","rain","pulse"
];

let modeIndex = 0;
let transitionSpeed = 0.05;

/* ================= SHAPE GENERATOR ================= */
function generateShape(type) {
  for (let i = 0; i < COUNT; i++) {
    const t = i / COUNT * Math.PI * 2;
    let x=0,y=0,z=0;

    switch(type) {
      case "heart":
        x = 16 * Math.pow(Math.sin(t),3);
        y = -(13*Math.cos(t)-5*Math.cos(2*t));
        break;

      case "flower":
        const r = 25 * Math.sin(6*t);
        x = r * Math.cos(t);
        y = r * Math.sin(t);
        break;

      case "saturn":
        x = 30 * Math.cos(t);
        y = 6 * Math.sin(t*3);
        z = 30 * Math.sin(t);
        break;

      case "firework":
        x = (Math.random()-0.5)*80;
        y = (Math.random()-0.5)*80;
        z = (Math.random()-0.5)*80;
        break;

      case "spiral":
        x = Math.cos(t*6) * t * 4;
        y = Math.sin(t*6) * t * 4;
        z = (i/COUNT - 0.5) * 80;
        break;

      case "wave":
        x = (i/COUNT - 0.5) * 100;
        y = Math.sin(t*8) * 20;
        break;

      case "galaxy":
        x = Math.cos(t*4) * 40;
        y = (Math.random()-0.5)*10;
        z = Math.sin(t*4) * 40;
        break;

      case "vortex":
        x = Math.cos(t*12) * (i/COUNT)*60;
        y = Math.sin(t*12) * (i/COUNT)*60;
        break;

      case "dna":
        x = Math.cos(t*8) * 18;
        y = (i/COUNT - 0.5)*80;
        z = Math.sin(t*8) * 18;
        break;

      case "sphere":
        const phi = Math.acos(1 - 2*(i/COUNT));
        const theta = Math.PI * (1 + Math.sqrt(5)) * i;
        x = 35 * Math.cos(theta) * Math.sin(phi);
        y = 35 * Math.sin(theta) * Math.sin(phi);
        z = 35 * Math.cos(phi);
        break;

      case "ring":
        x = Math.cos(t)*40;
        z = Math.sin(t)*40;
        break;

      case "helix":
        x = Math.cos(t*10)*25;
        y = (i/COUNT - 0.5)*90;
        z = Math.sin(t*10)*25;
        break;

      case "cube":
        x = (Math.random()-0.5)*50;
        y = (Math.random()-0.5)*50;
        z = (Math.random()-0.5)*50;
        break;

      case "explosion":
        x = (Math.random()-0.5)*120;
        y = (Math.random()-0.5)*120;
        z = (Math.random()-0.5)*120;
        break;

      case "rain":
        x = (Math.random()-0.5)*80;
        y = Math.random()*100;
        z = (Math.random()-0.5)*80;
        break;

      case "pulse":
        x = positions[i*3] * 1.4;
        y = positions[i*3+1] * 1.4;
        z = positions[i*3+2] * 1.4;
        break;
    }

    targetPositions[i*3] = x;
    targetPositions[i*3+1] = y;
    targetPositions[i*3+2] = z;
  }
}

/* ================= DEBUG SPHERE ================= */
const debugSphere = new THREE.Mesh(
  new THREE.SphereGeometry(1.8),
  new THREE.MeshBasicMaterial({ color: 0xff0000 })
);
scene.add(debugSphere);

/* ================= HAND TRACKING ================= */
const video = document.getElementById("video");

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(onResults);

const cam = new Camera(video, {
  onFrame: async () => await hands.send({ image: video }),
  width: 640,
  height: 480
});
cam.start();

let lastX = null;

function onResults(res) {
  if (!res.multiHandLandmarks?.length) return;

  const hand = res.multiHandLandmarks[0];
  const thumb = hand[4];
  const index = hand[8];

  debugSphere.position.set(
    (index.x - 0.5) * 150,
    -(index.y - 0.5) * 150,
    0
  );

  const pinch = Math.hypot(thumb.x-index.x, thumb.y-index.y);
  particles.scale.setScalar(THREE.MathUtils.clamp(pinch * 28, 0.7, 3.8));
  transitionSpeed = THREE.MathUtils.clamp(pinch * 0.4, 0.02, 0.12);

  const hue = 1 - index.y;
  for (let i = 0; i < COUNT; i++) {
    color.setHSL(hue, 1, 0.6);
    colors[i*3] = color.r;
    colors[i*3+1] = color.g;
    colors[i*3+2] = color.b;
  }
  geometry.attributes.color.needsUpdate = true;

  if (lastX !== null) {
    const dx = index.x - lastX;
    if (dx > 0.05) {
      modeIndex = (modeIndex + 1) % MODES.length;
      generateShape(MODES[modeIndex]);
      lastX = null;
      return;
    }
  }
  lastX = index.x;
}

/* ================= ANIMATION ================= */
function animate() {
  requestAnimationFrame(animate);

  for (let i = 0; i < positions.length; i++) {
    positions[i] += (targetPositions[i] - positions[i]) * transitionSpeed;
  }
  geometry.attributes.position.needsUpdate = true;

  particles.rotation.y += 0.002;
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
